# 面向对象III

## A. 继承，面向对象三大特性之一

### 1.继承机制

* Java支持单继承，不直接支持多继承，但对C++的多继承机制进行了改良
  * 单继承：一个子类只能有一个直接父类
  * 多继承：一个子类可以有多个直接父类（原因：会因为多个直接父类拥有相同成员会导致调用的不确定性），在Java中，该功能通过『多实现』的方式来体现的

### 2.成员的特点

* 本类和局部成员同名用**this**区分；子类和父类成员同名用**super**区分
* this代表本类对象的引用，而super不代表父类对象的引用，代表的是**父类存储空间的标识**
* 当子类和父类拥有同样的成员，在未明确使用super关键字时，子类的成员优先，称为重写（或覆盖，override），其注意事项如下（方法）
  * 首先如要重写，那么方法所用参数，返回值类型以及方法名必须一致
  * 子类方法重写父类方法，子类的方法权限一定要大于等于父类的方法权限（private修饰父类方法不能重写，因为这是父类的独有内容，子类不能直接使用）
  * 静态方法只能重写静态方法，或是被静态方法重写，即父类和子类的方法都是静态的，有一方不为静态都是不成立的

### 3.构造方法

* 子类的构造方法的第一行有一个默认的隐式语句：**super();**，子类实例化，子类中的所有构造方法都会默认访问父类的空参的构造方法，如下代码

  ```java
  public class Father{
    Father(){
      System.out.println("Method1 Run!");
    }
    Father(int f){
      System.out.println("Method2 Run!");
    }
  }
  
  public class Son extends Father{
    Son(){
      // 第一句，隐式语句：super();
      System.out.println("Method3 Run!");
    }
    Son(int s){
      System.out.println("Method4 Run!");
    }
  }
  
  public class Demo{
    public static void main(String[] args){
      new Son();
      
      // 输出结果是：Method1 Run!
      //           Method3 Run!
    }
  }
  ```

* 子类实例化需要访问父类构造方法的原因及注意事项

  * 因为子类继承了父类的内容（属性），在使用父类之前，要先看父类是如何对自己的内容进行初始化操作的。故而在子类构造对象时，必须要访问父类的构造方法，使用super关键字
  * 注意1：super语句必须要定义在子类构造方法的第一行
  * 注意2：如果父类没有无参的构造方法，那么子类构造方法必须使用super明确调用父类的构造方法

