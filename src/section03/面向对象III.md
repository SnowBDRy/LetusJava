# 面向对象III

## A. 继承（面向对象三大特性之一）

### 1.继承机制

* Java支持单继承，不直接支持多继承，但对C++的多继承机制进行了改良
  * 单继承：一个子类只能有一个直接父类
  * 多继承：一个子类可以有多个直接父类（原因：会因为多个直接父类拥有相同成员会导致调用的不确定性），在Java中，该功能通过『多实现』的方式来体现的

### 2.成员的特点

* 本类和局部成员同名用**this**区分；子类和父类成员同名用**super**区分
* this代表本类对象的引用，而super不代表父类对象的引用，代表的是**父类存储空间的标识**
* 当子类和父类拥有同样的成员，在未明确使用super关键字时，子类的成员优先，称为重写（或覆盖，override），其注意事项如下（方法）
  * 首先如要重写，那么方法所用参数，返回值类型以及方法名必须一致
  * 子类方法重写父类方法，子类的方法权限一定要大于等于父类的方法权限（private修饰父类方法不能重写，因为这是父类的独有内容，子类不能直接使用）
  * 静态方法只能重写静态方法，或是被静态方法重写，即父类和子类的方法都是静态的，有一方不为静态都是不成立的

### 3.构造方法

* 子类的构造方法的第一行有一个默认的隐式语句：**super();**，子类实例化，子类中的所有构造方法都会默认访问父类的空参的构造方法，如下代码

  ```java
  public class Father{
    Father(){
      System.out.println("Method1 Run!");
    }
    Father(int f){
      System.out.println("Method2 Run!");
    }
  }
  
  public class Son extends Father{
    Son(){
      // 第一句，隐式语句：super();
      System.out.println("Method3 Run!");
    }
    Son(int s){
      System.out.println("Method4 Run!");
    }
  }
  
  public class Demo{
    public static void main(String[] args){
      new Son();
      
      // 输出结果是：Method1 Run!
      //           Method3 Run!
    }
  }
  ```

* 子类实例化需要访问父类构造方法的原因及注意事项

  * 因为子类继承了父类的内容（属性），在使用父类之前，要先看父类是如何对自己的内容进行初始化操作的。故而在子类构造对象时，必须要访问父类的构造方法，使用super关键字
  * 注意1：super语句必须要定义在子类构造方法的第一行（隐式）
  * 注意2：如果父类没有无参的构造方法，那么子类构造方法必须使用super明确调用父类的构造方法
  * 注意3：子类的构造方法中如果使用了this来调用本类中的构造方法，那么super就不存在了，因为super和this都只能定义在第一行，二者只能存一，但是可以保证的是：子类会有其他构造方法来访问父类的构造方法
  
* 一个对象实例化的过程：

  * 1.JVM会读取指定路径下的.class 文件，并加载到内存中（方法区），并会优先加载父类（如果有直接父类的情况下）
  * 2.在堆内存开辟空间并分配地址
  * 3.在对象空间内，对对象的成员进行默认初始化操作
  * 4.调用对应的构造方法来进行初始化，在调用构造方法时第一行会先调用父类的构造方法进行父类的初始化
  * 5.在父类的初始化完毕后才会进行子类属性进行显式初始化
  * 6.子类构造方法进行特定的初始化
  * 7.全部初始化完毕后，将对象的地址赋给引用变量

  ```java
  public class Father{
    Father(){
      show();
    }
    
    void show(){
      System.out.println("Father Show");
    }
  }
  
  public class Son extends Father{
    int num = 8;
    Son(){
      // 隐式super();
      // 在执行super初始化父类的时候，子类的成员并未初始化，只有在super完成父类的初始化后，才会进行子类成员的初始化
    }  
    
    @Override
    void show(){
      System.out.println("Son Show" + num);
    }
  }
  
  public class Demo{
    public static void main(String[] args){
      Son s = new Son();
      s.show();
      // 这个结果应该是：
      // Son Show0
      // Son Show8
    }
  }
  ```

  * 内存图解如下：

    ![继承下构造方法图解](https://cdn.jsdelivr.net/gh/SnowBDRy/mos@master/uPic/继承下构造方法图解.png)
    

### 4.final关键字

* 继承虽然增加的程序的灵活性，同时也有弊端存在，即破坏了封装，**final**应运而生，final可以用来修饰类、成员变量、方法
* 被final修饰的类不可以被继承，被final修饰的方法不可以被覆盖，被final修饰的变量是一个常量，只能赋值一次
* 命名规约：被final修饰的变量，变量名全部大写，多个单词中间用**_**连接

## B. 抽象（重点掌握）

### 1.概述

* 抽象类在继承关系中使用特别频繁，用于创建父类，其方法是用来覆盖的。注意：使用对象是方法，成员变量不可以使用

* 如果父类当中的方法不能确定如何进行{}方法体实现，那么这就应该是一个抽象方法

  ```java
  // 基本写法
  public abstract class Demo(){
    public abstract void show();
  }
  ```

### 2.特性

* 抽象方法必须定义在抽象类中，如果一个方法被abstract修饰了，那么这个类也必须被abstract修饰
* 抽象类不可以被实例化，不能使用new关键字创建对象（没有实际的方法体，调用没有意义）
* 抽象类必须有其子类覆盖所有的抽象方法后，该子类才可以实例化，否则，该子类依然为抽象类
* 抽象类中存在构造方法，用于给子类初始化
* 抽象类可以不定义抽象方法，其目的不让该类创建对象（AWT适配器对象即是这种类）
* 抽象关键字abstract和private、static、final同时存在
  * 不能和private一起使用的原因：访问权限为私有，子类无法覆盖父类方法，但是父类方法没有方法体，没有意义
  * 不能和static一起使用的原因：设为静态，即不需要对象直接使用类名即可调用方法，但是父类没有方法体，没有意义
  * 不能和final一起使用的原因：被final修饰的方法不可以被覆盖，但是父类没有方法体，没有意义
* 抽象类一定是父类，必须有子类对其进行方法的覆盖



### 3.抽象练习

* 公司雇员建模（参照Employee.java、Programmer.java、Manager.java）
  * 需求1：公司的程序员有姓名、工号、薪水和工作内容
  * 需求2：公司的项目经理有姓名、工号、新书、工作内容和奖金

### 4.接口

* 一种特殊的抽象类，其方法全部都是抽象方法的类

* 接口中常见的成员都有默认固定的修饰符，省略或写的不全会自动补全修饰符

  * 成员变量：public static final（隐式）
  * 方法：public abstract（隐式）

* 接口与类之间是实现关系**implements**

* 接口不能实例化，只能由实现了接口内所有抽象方法后才能，该子类才可以实例化，否则，该子类为一个抽象类

* 接口可以多实现

  ```java
  public interface A{
    void show();
  }
  
  public interface B{
    void show();
  }
  
  public class DemoImpl implements A, B{
    // 这个子类实现A和B两个的show方法
    @Override
    public void show(){
      System.out.println("Impl");
    }
  }
  ```

* 继承和实现可以组合，一个类既可以继承另一个类的同时，还可以实现多个接口

  * 接口的出现避免了单继承的局限性
  * 接口的出现增强了类的拓展性

* 类与类之间是继承关系，且为单继承；类与接口之间是实现关系，可以多实现；接口于接口之间是继承关系，可以多继承（因为没有方法体）

* 接口类型的引用，用于接收（指向）接口的子类对象

* 接口和抽象类的不同之处：

  * 抽象类需要被继承且为单继承；接口需要被实现且可以多实现
  * 抽象类中可以定义抽象方法和普通方法；接口只能定义抽象方法
  * 抽象类的继承是所属关系（is-a）；接口是实现关系（like a）